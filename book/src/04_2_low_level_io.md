# Low level I/O How to manipulate Registers

## How does the mapping from register to software work?

In general there are two ways to write firmware for the esp32. One is the bare-metal using only `[no_std]` Rust, and the other using `[std]` Rust and C-Bindings to the esp-idf.
`[no_std]` Rust refers to Rust not using the standard library, only the core library, which is a subset of the standard library that does not depend on the existence of an operating system. 

### Bare metal Rust with `[no_std]`

Registers and their fields on a device are described in system view description (svd) files. `svd2rust` is used to generate peripheral access crates (PACs) from them. PACS provide a thin wrapper over the various memory-wrapper registers defined for the particular part-number of micro-controller you are using. While it is possible to write code with a PAC alone, a lot of it would be unsafe or otherwise inconvenient as it only provides the basic perhipherals of the microcontroller. So there is another layer, the Hardware Abstraction Layer (HAL). HALs provide a more user friendly API for the chip, and often implement common traits defined in the embedded-hal. For some specific development Kits board support crates exist. They provide yet another layer of abstraction for specific development kits and additionally provide an api to sensors and LEDs that are on the board.

Bare-metal Rust is highly experimental on esp32c3 chips, so for now we will not work with it. But a PAC for the esp32c3 exists:, [esp32c3](https://github.com/esp-rs/esp32c3) provides the peripheral access create generated by svd2rust.


### `[std]` Rust and the esp-idf

 The esp-idf is mostly written in C and as such is exposed to Rust in the canonical split crate style: 
- a `sys` crate to provide the actual `unsafe` bindings ([esp-idf-sys](https://github.com/esp-rs/esp-idf-sys))
- a higher level crate offering safe and comfortable Rust abstractions ([esp-idf-svc](https://github.com/esp-rs/esp-idf-svc/))

The final piece of the puzzle is low-level hardware access, which is again provided in a split fashion:
- [esp-idf-hal](https://github.com/esp-rs/esp-idf-hal) implements the hardware-independent [embedded-hal](https://github.com/rust-embedded/embedded-hal) traits like analog/digital conversion, digital I/O pins, or SPI communication - as the name suggests, it also uses `esp-idf` as a foundation

More information is available in the [ecosystem chapter](https://esp-rs.github.io/book/overview/using-the-standard-library.html) of the `esp-rs` book.


This is the way that currently allows the most possibilities on espressif chips if you want to use Rust, and everything in this course is based on this approach. 


TODO svd2rust, register manipulation edge vs level triggered interrupts, (atomics emulated via ISR -> can't use in own ISR)

## 

## Register Manipulation with C bindings: Configuring a GPIO

Pins are configured with the `c struct` `gpio_config_t`. The struct has the following fields:

* `pin_bit_mask`: represents the Pin number
* `mode`: sets the mode of the pin, it can have the following settings:
  * `gpio_mode_t_GPIO_MODE_INPUT`
  * `gpio_mode_t_GPIO_MODE_OUTPUT`
  * `gpio_mode_t_GPIO_MODE_DISABLE`
  * `gpio_mode_t_GPIO_MODE_OUTPUT_OD`
  * `gpio_mode_t_GPIO_MODE_INPUT_OUTPUT`
  * `gpio_mode_t_GPIO_MODE_INPUT_OUTPUT_OD`

They are constants with numbers representing the bit that must be set in the corresponding register. 

* `pull_up_en`: true.into(), if the GPIO is pulled up,
* `pull_down_en`: true.into(), if the GPIO is pulled down,
* `intr_type`: sets the interrupt type, it can have the following settings:
  * `gpio_int_type_t_GPIO_INTR_MAX`
  * `gpio_int_type_t_GPIO_INTR_ANYEDGE`
  * `gpio_int_type_t_GPIO_INTR_DISABLE`
  * `gpio_int_type_t_GPIO_INTR_NEGEDGE`
  * `gpio_int_type_t_GPIO_INTR_POSEDGE`



example pin configuration: 

TODO Change to a different example, not the one from interrupt exercise
TODO Add verbal description of configuration

```rust
pub struct gpio_config_t {
    pub pin_bit_mask: u64,
    pub mode: gpio_mode_t,
    pub pull_up_en: gpio_pullup_t,
    pub pull_down_en: gpio_pulldown_t,
    pub intr_type: gpio_int_type_t,
}

let io_conf = gpio_config_t {
        pin_bit_mask: 1 << 9,
        mode: gpio_mode_t_GPIO_MODE_INPUT,
        pull_up_en: true.into(),
        pull_down_en: false.into(),
        intr_type: gpio_int_type_t_GPIO_INTR_POSEDGE, // positive edge trigger = button down
    };
```

